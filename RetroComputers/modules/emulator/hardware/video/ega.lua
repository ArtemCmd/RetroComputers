-- =====================================================================================================================================================================
-- IBM Enhanced Graphics Adapter (EGA) emulation.
-- =====================================================================================================================================================================

local common = require("retro_computers:emulator/hardware/video/common")
local filesystem = require("retro_computers:emulator/filesystem")
local band, bor, rshift, lshift, bxor, bnot = bit.band, bit.bor, bit.rshift, bit.lshift, bit.bxor, bit.bnot

local ega = {}

local EGA_ROM = filesystem.open("retro_computers:modules/emulator/roms/video/EGABIOS.BIN", "r", true):read_bytes()

local ega_rotate = {
    [0] = 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
    0x00, 0x80, 0x01, 0x81, 0x02, 0x82, 0x03, 0x83, 0x04, 0x84, 0x05, 0x85, 0x06, 0x86, 0x07, 0x87, 0x08, 0x88, 0x09, 0x89, 0x0A, 0x8A, 0x0B, 0x8B, 0x0C, 0x8C, 0x0D, 0x8D, 0x0E, 0x8E, 0x0F, 0x8F, 0x10, 0x90, 0x11, 0x91, 0x12, 0x92, 0x13, 0x93, 0x14, 0x94, 0x15, 0x95, 0x16, 0x96, 0x17, 0x97, 0x18, 0x98, 0x19, 0x99, 0x1A, 0x9A, 0x1B, 0x9B, 0x1C, 0x9C, 0x1D, 0x9D, 0x1E, 0x9E, 0x1F, 0x9F, 0x20, 0xA0, 0x21, 0xA1, 0x22, 0xA2, 0x23, 0xA3, 0x24, 0xA4, 0x25, 0xA5, 0x26, 0xA6, 0x27, 0xA7, 0x28, 0xA8, 0x29, 0xA9, 0x2A, 0xAA, 0x2B, 0xAB, 0x2C, 0xAC, 0x2D, 0xAD, 0x2E, 0xAE, 0x2F, 0xAF, 0x30, 0xB0, 0x31, 0xB1, 0x32, 0xB2, 0x33, 0xB3, 0x34, 0xB4, 0x35, 0xB5, 0x36, 0xB6, 0x37, 0xB7, 0x38, 0xB8, 0x39, 0xB9, 0x3A, 0xBA, 0x3B, 0xBB, 0x3C, 0xBC, 0x3D, 0xBD, 0x3E, 0xBE, 0x3F, 0xBF, 0x40, 0xC0, 0x41, 0xC1, 0x42, 0xC2, 0x43, 0xC3, 0x44, 0xC4, 0x45, 0xC5, 0x46, 0xC6, 0x47, 0xC7, 0x48, 0xC8, 0x49, 0xC9, 0x4A, 0xCA, 0x4B, 0xCB, 0x4C, 0xCC, 0x4D, 0xCD, 0x4E, 0xCE, 0x4F, 0xCF, 0x50, 0xD0, 0x51, 0xD1, 0x52, 0xD2, 0x53, 0xD3, 0x54, 0xD4, 0x55, 0xD5, 0x56, 0xD6, 0x57, 0xD7, 0x58, 0xD8, 0x59, 0xD9, 0x5A, 0xDA, 0x5B, 0xDB, 0x5C, 0xDC, 0x5D, 0xDD, 0x5E, 0xDE, 0x5F, 0xDF, 0x60, 0xE0, 0x61, 0xE1, 0x62, 0xE2, 0x63, 0xE3, 0x64, 0xE4, 0x65, 0xE5, 0x66, 0xE6, 0x67, 0xE7, 0x68, 0xE8, 0x69, 0xE9, 0x6A, 0xEA, 0x6B, 0xEB, 0x6C, 0xEC, 0x6D, 0xED, 0x6E, 0xEE, 0x6F, 0xEF, 0x70, 0xF0, 0x71, 0xF1, 0x72, 0xF2, 0x73, 0xF3, 0x74, 0xF4, 0x75, 0xF5, 0x76, 0xF6, 0x77, 0xF7, 0x78, 0xF8, 0x79, 0xF9, 0x7A, 0xFA, 0x7B, 0xFB, 0x7C, 0xFC, 0x7D, 0xFD, 0x7E, 0xFE, 0x7F, 0xFF,
    0x00, 0x40, 0x80, 0xC0, 0x01, 0x41, 0x81, 0xC1, 0x02, 0x42, 0x82, 0xC2, 0x03, 0x43, 0x83, 0xC3, 0x04, 0x44, 0x84, 0xC4, 0x05, 0x45, 0x85, 0xC5, 0x06, 0x46, 0x86, 0xC6, 0x07, 0x47, 0x87, 0xC7, 0x08, 0x48, 0x88, 0xC8, 0x09, 0x49, 0x89, 0xC9, 0x0A, 0x4A, 0x8A, 0xCA, 0x0B, 0x4B, 0x8B, 0xCB, 0x0C, 0x4C, 0x8C, 0xCC, 0x0D, 0x4D, 0x8D, 0xCD, 0x0E, 0x4E, 0x8E, 0xCE, 0x0F, 0x4F, 0x8F, 0xCF, 0x10, 0x50, 0x90, 0xD0, 0x11, 0x51, 0x91, 0xD1, 0x12, 0x52, 0x92, 0xD2, 0x13, 0x53, 0x93, 0xD3, 0x14, 0x54, 0x94, 0xD4, 0x15, 0x55, 0x95, 0xD5, 0x16, 0x56, 0x96, 0xD6, 0x17, 0x57, 0x97, 0xD7, 0x18, 0x58, 0x98, 0xD8, 0x19, 0x59, 0x99, 0xD9, 0x1A, 0x5A, 0x9A, 0xDA, 0x1B, 0x5B, 0x9B, 0xDB, 0x1C, 0x5C, 0x9C, 0xDC, 0x1D, 0x5D, 0x9D, 0xDD, 0x1E, 0x5E, 0x9E, 0xDE, 0x1F, 0x5F, 0x9F, 0xDF, 0x20, 0x60, 0xA0, 0xE0, 0x21, 0x61, 0xA1, 0xE1, 0x22, 0x62, 0xA2, 0xE2, 0x23, 0x63, 0xA3, 0xE3, 0x24, 0x64, 0xA4, 0xE4, 0x25, 0x65, 0xA5, 0xE5, 0x26, 0x66, 0xA6, 0xE6, 0x27, 0x67, 0xA7, 0xE7, 0x28, 0x68, 0xA8, 0xE8, 0x29, 0x69, 0xA9, 0xE9, 0x2A, 0x6A, 0xAA, 0xEA, 0x2B, 0x6B, 0xAB, 0xEB, 0x2C, 0x6C, 0xAC, 0xEC, 0x2D, 0x6D, 0xAD, 0xED, 0x2E, 0x6E, 0xAE, 0xEE, 0x2F, 0x6F, 0xAF, 0xEF, 0x30, 0x70, 0xB0, 0xF0, 0x31, 0x71, 0xB1, 0xF1, 0x32, 0x72, 0xB2, 0xF2, 0x33, 0x73, 0xB3, 0xF3, 0x34, 0x74, 0xB4, 0xF4, 0x35, 0x75, 0xB5, 0xF5, 0x36, 0x76, 0xB6, 0xF6, 0x37, 0x77, 0xB7, 0xF7, 0x38, 0x78, 0xB8, 0xF8, 0x39, 0x79, 0xB9, 0xF9, 0x3A, 0x7A, 0xBA, 0xFA, 0x3B, 0x7B, 0xBB, 0xFB, 0x3C, 0x7C, 0xBC, 0xFC, 0x3D, 0x7D, 0xBD, 0xFD, 0x3E, 0x7E, 0xBE, 0xFE, 0x3F, 0x7F, 0xBF, 0xFF,
    0x00, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0, 0x01, 0x21, 0x41, 0x61, 0x81, 0xA1, 0xC1, 0xE1, 0x02, 0x22, 0x42, 0x62, 0x82, 0xA2, 0xC2, 0xE2, 0x03, 0x23, 0x43, 0x63, 0x83, 0xA3, 0xC3, 0xE3, 0x04, 0x24, 0x44, 0x64, 0x84, 0xA4, 0xC4, 0xE4, 0x05, 0x25, 0x45, 0x65, 0x85, 0xA5, 0xC5, 0xE5, 0x06, 0x26, 0x46, 0x66, 0x86, 0xA6, 0xC6, 0xE6, 0x07, 0x27, 0x47, 0x67, 0x87, 0xA7, 0xC7, 0xE7, 0x08, 0x28, 0x48, 0x68, 0x88, 0xA8, 0xC8, 0xE8, 0x09, 0x29, 0x49, 0x69, 0x89, 0xA9, 0xC9, 0xE9, 0x0A, 0x2A, 0x4A, 0x6A, 0x8A, 0xAA, 0xCA, 0xEA, 0x0B, 0x2B, 0x4B, 0x6B, 0x8B, 0xAB, 0xCB, 0xEB, 0x0C, 0x2C, 0x4C, 0x6C, 0x8C, 0xAC, 0xCC, 0xEC, 0x0D, 0x2D, 0x4D, 0x6D, 0x8D, 0xAD, 0xCD, 0xED, 0x0E, 0x2E, 0x4E, 0x6E, 0x8E, 0xAE, 0xCE, 0xEE, 0x0F, 0x2F, 0x4F, 0x6F, 0x8F, 0xAF, 0xCF, 0xEF, 0x10, 0x30, 0x50, 0x70, 0x90, 0xB0, 0xD0, 0xF0, 0x11, 0x31, 0x51, 0x71, 0x91, 0xB1, 0xD1, 0xF1, 0x12, 0x32, 0x52, 0x72, 0x92, 0xB2, 0xD2, 0xF2, 0x13, 0x33, 0x53, 0x73, 0x93, 0xB3, 0xD3, 0xF3, 0x14, 0x34, 0x54, 0x74, 0x94, 0xB4, 0xD4, 0xF4, 0x15, 0x35, 0x55, 0x75, 0x95, 0xB5, 0xD5, 0xF5, 0x16, 0x36, 0x56, 0x76, 0x96, 0xB6, 0xD6, 0xF6, 0x17, 0x37, 0x57, 0x77, 0x97, 0xB7, 0xD7, 0xF7, 0x18, 0x38, 0x58, 0x78, 0x98, 0xB8, 0xD8, 0xF8, 0x19, 0x39, 0x59, 0x79, 0x99, 0xB9, 0xD9, 0xF9, 0x1A, 0x3A, 0x5A, 0x7A, 0x9A, 0xBA, 0xDA, 0xFA, 0x1B, 0x3B, 0x5B, 0x7B, 0x9B, 0xBB, 0xDB, 0xFB, 0x1C, 0x3C, 0x5C, 0x7C, 0x9C, 0xBC, 0xDC, 0xFC, 0x1D, 0x3D, 0x5D, 0x7D, 0x9D, 0xBD, 0xDD, 0xFD, 0x1E, 0x3E, 0x5E, 0x7E, 0x9E, 0xBE, 0xDE, 0xFE, 0x1F, 0x3F, 0x5F, 0x7F, 0x9F, 0xBF, 0xDF, 0xFF,
    0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71, 0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1, 0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72, 0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2, 0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73, 0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3, 0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74, 0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4, 0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75, 0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5, 0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76, 0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6, 0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77, 0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7, 0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78, 0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8, 0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79, 0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9, 0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A, 0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA, 0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B, 0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB, 0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C, 0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC, 0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D, 0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD, 0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E, 0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE, 0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F, 0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF,
    0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38, 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78, 0x80, 0x88, 0x90, 0x98, 0xA0, 0xA8, 0xB0, 0xB8, 0xC0, 0xC8, 0xD0, 0xD8, 0xE0, 0xE8, 0xF0, 0xF8, 0x01, 0x09, 0x11, 0x19, 0x21, 0x29, 0x31, 0x39, 0x41, 0x49, 0x51, 0x59, 0x61, 0x69, 0x71, 0x79, 0x81, 0x89, 0x91, 0x99, 0xA1, 0xA9, 0xB1, 0xB9, 0xC1, 0xC9, 0xD1, 0xD9, 0xE1, 0xE9, 0xF1, 0xF9, 0x02, 0x0A, 0x12, 0x1A, 0x22, 0x2A, 0x32, 0x3A, 0x42, 0x4A, 0x52, 0x5A, 0x62, 0x6A, 0x72, 0x7A, 0x82, 0x8A, 0x92, 0x9A, 0xA2, 0xAA, 0xB2, 0xBA, 0xC2, 0xCA, 0xD2, 0xDA, 0xE2, 0xEA, 0xF2, 0xFA, 0x03, 0x0B, 0x13, 0x1B, 0x23, 0x2B, 0x33, 0x3B, 0x43, 0x4B, 0x53, 0x5B, 0x63, 0x6B, 0x73, 0x7B, 0x83, 0x8B, 0x93, 0x9B, 0xA3, 0xAB, 0xB3, 0xBB, 0xC3, 0xCB, 0xD3, 0xDB, 0xE3, 0xEB, 0xF3, 0xFB, 0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C, 0x44, 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C, 0x84, 0x8C, 0x94, 0x9C, 0xA4, 0xAC, 0xB4, 0xBC, 0xC4, 0xCC, 0xD4, 0xDC, 0xE4, 0xEC, 0xF4, 0xFC, 0x05, 0x0D, 0x15, 0x1D, 0x25, 0x2D, 0x35, 0x3D, 0x45, 0x4D, 0x55, 0x5D, 0x65, 0x6D, 0x75, 0x7D, 0x85, 0x8D, 0x95, 0x9D, 0xA5, 0xAD, 0xB5, 0xBD, 0xC5, 0xCD, 0xD5, 0xDD, 0xE5, 0xED, 0xF5, 0xFD, 0x06, 0x0E, 0x16, 0x1E, 0x26, 0x2E, 0x36, 0x3E, 0x46, 0x4E, 0x56, 0x5E, 0x66, 0x6E, 0x76, 0x7E, 0x86, 0x8E, 0x96, 0x9E, 0xA6, 0xAE, 0xB6, 0xBE, 0xC6, 0xCE, 0xD6, 0xDE, 0xE6, 0xEE, 0xF6, 0xFE, 0x07, 0x0F, 0x17, 0x1F, 0x27, 0x2F, 0x37, 0x3F, 0x47, 0x4F, 0x57, 0x5F, 0x67, 0x6F, 0x77, 0x7F, 0x87, 0x8F, 0x97, 0x9F, 0xA7, 0xAF, 0xB7, 0xBF, 0xC7, 0xCF, 0xD7, 0xDF, 0xE7, 0xEF, 0xF7, 0xFF,
    0x00, 0x04, 0x08, 0x0C, 0x10, 0x14, 0x18, 0x1C, 0x20, 0x24, 0x28, 0x2C, 0x30, 0x34, 0x38, 0x3C, 0x40, 0x44, 0x48, 0x4C, 0x50, 0x54, 0x58, 0x5C, 0x60, 0x64, 0x68, 0x6C, 0x70, 0x74, 0x78, 0x7C, 0x80, 0x84, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC, 0xC0, 0xC4, 0xC8, 0xCC, 0xD0, 0xD4, 0xD8, 0xDC, 0xE0, 0xE4, 0xE8, 0xEC, 0xF0, 0xF4, 0xF8, 0xFC, 0x01, 0x05, 0x09, 0x0D, 0x11, 0x15, 0x19, 0x1D, 0x21, 0x25, 0x29, 0x2D, 0x31, 0x35, 0x39, 0x3D, 0x41, 0x45, 0x49, 0x4D, 0x51, 0x55, 0x59, 0x5D, 0x61, 0x65, 0x69, 0x6D, 0x71, 0x75, 0x79, 0x7D, 0x81, 0x85, 0x89, 0x8D, 0x91, 0x95, 0x99, 0x9D, 0xA1, 0xA5, 0xA9, 0xAD, 0xB1, 0xB5, 0xB9, 0xBD, 0xC1, 0xC5, 0xC9, 0xCD, 0xD1, 0xD5, 0xD9, 0xDD, 0xE1, 0xE5, 0xE9, 0xED, 0xF1, 0xF5, 0xF9, 0xFD, 0x02, 0x06, 0x0A, 0x0E, 0x12, 0x16, 0x1A, 0x1E, 0x22, 0x26, 0x2A, 0x2E, 0x32, 0x36, 0x3A, 0x3E, 0x42, 0x46, 0x4A, 0x4E, 0x52, 0x56, 0x5A, 0x5E, 0x62, 0x66, 0x6A, 0x6E, 0x72, 0x76, 0x7A, 0x7E, 0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E, 0xA2, 0xA6, 0xAA, 0xAE, 0xB2, 0xB6, 0xBA, 0xBE, 0xC2, 0xC6, 0xCA, 0xCE, 0xD2, 0xD6, 0xDA, 0xDE, 0xE2, 0xE6, 0xEA, 0xEE, 0xF2, 0xF6, 0xFA, 0xFE, 0x03, 0x07, 0x0B, 0x0F, 0x13, 0x17, 0x1B, 0x1F, 0x23, 0x27, 0x2B, 0x2F, 0x33, 0x37, 0x3B, 0x3F, 0x43, 0x47, 0x4B, 0x4F, 0x53, 0x57, 0x5B, 0x5F, 0x63, 0x67, 0x6B, 0x6F, 0x73, 0x77, 0x7B, 0x7F, 0x83, 0x87, 0x8B, 0x8F, 0x93, 0x97, 0x9B, 0x9F, 0xA3, 0xA7, 0xAB, 0xAF, 0xB3, 0xB7, 0xBB, 0xBF, 0xC3, 0xC7, 0xCB, 0xCF, 0xD3, 0xD7, 0xDB, 0xDF, 0xE3, 0xE7, 0xEB, 0xEF, 0xF3, 0xF7, 0xFB, 0xFF,
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5A, 0x5C, 0x5E, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x7C, 0x7E, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E, 0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE, 0xB0, 0xB2, 0xB4, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE, 0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE, 0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE, 0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFE, 0x01, 0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x11, 0x13, 0x15, 0x17, 0x19, 0x1B, 0x1D, 0x1F, 0x21, 0x23, 0x25, 0x27, 0x29, 0x2B, 0x2D, 0x2F, 0x31, 0x33, 0x35, 0x37, 0x39, 0x3B, 0x3D, 0x3F, 0x41, 0x43, 0x45, 0x47, 0x49, 0x4B, 0x4D, 0x4F, 0x51, 0x53, 0x55, 0x57, 0x59, 0x5B, 0x5D, 0x5F, 0x61, 0x63, 0x65, 0x67, 0x69, 0x6B, 0x6D, 0x6F, 0x71, 0x73, 0x75, 0x77, 0x79, 0x7B, 0x7D, 0x7F, 0x81, 0x83, 0x85, 0x87, 0x89, 0x8B, 0x8D, 0x8F, 0x91, 0x93, 0x95, 0x97, 0x99, 0x9B, 0x9D, 0x9F, 0xA1, 0xA3, 0xA5, 0xA7, 0xA9, 0xAB, 0xAD, 0xAF, 0xB1, 0xB3, 0xB5, 0xB7, 0xB9, 0xBB, 0xBD, 0xBF, 0xC1, 0xC3, 0xC5, 0xC7, 0xC9, 0xCB, 0xCD, 0xCF, 0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 0xDF, 0xE1, 0xE3, 0xE5, 0xE7, 0xE9, 0xEB, 0xED, 0xEF, 0xF1, 0xF3, 0xF5, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
}

local cga2ega = {
    [0] = 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03, 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
    0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07, 0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
    0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03, 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
    0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07, 0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
    0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B, 0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F, 0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F,
    0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B, 0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F, 0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F,
    0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03, 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
    0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07, 0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
    0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03, 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03,
    0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07, 0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x06, 0x07,
    0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B, 0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F, 0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F,
    0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B, 0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F, 0x0C, 0x0D, 0x0C, 0x0D, 0x0E, 0x0F, 0x0E, 0x0F
}

local palette64 = {
    [0] = 0x000000,
    0x0000AA,
    0x00AA00,
    0x00AAAA,
    0xAA0000,
    0xAA00AA,
    0xAAAA00,
    0xAAAAAA,
    0x000055,
    0x0000FF,
    0x00AA55,
    0x00AAFF,
    0xAA0055,
    0xAA00FF,
    0xAAAA55,
    0xAAAAFF,
    0x005500,
    0x0055AA,
    0x00FF00,
    0x00FFAA,
    0xAA5500,
    0xAA55AA,
    0xAAFF00,
    0xAAFFAA,
    0x005555,
    0x0055FF,
    0x00FF55,
    0x00FFFF,
    0xAA5555,
    0xAA55FF,
    0xAAFF55,
    0xAAFFFF,
    0x550000,
    0x5500AA,
    0x55AA00,
    0x55AAAA,
    0xFF0000,
    0xFF00AA,
    0xFFAA00,
    0xFFAAAA,
    0x550055,
    0x5500FF,
    0x55AA55,
    0x55AAFF,
    0xFF0055,
    0xFF00FF,
    0xFFAA55,
    0xFFAAFF,
    0x555500,
    0x5555AA,
    0x55FF00,
    0x55FFAA,
    0xFF5500,
    0xFF55AA,
    0xFFFF00,
    0xFFFFAA,
    0x555555,
    0x5555FF,
    0x55FF55,
    0x55FFFF,
    0xFF5555,
    0xFF55FF,
    0xFFFF55,
    0xFFFFFF
}

local palette16 = {
    [0] = 0x000000,
    0x0000AA,
    0x00AA00,
    0x00AAAA,
    0xAA0000,
    0xAA00AA,
    0xAA5500,
    0xAAAAAA,
    0x000000,
    0x0000AA,
    0x00AA00,
    0x00AAAA,
    0xAA0000,
    0xAA00AA,
    0xAA5500,
    0xAAAAAA,
    0x555555,
    0x5555FF,
    0x55FF55,
    0x55FFFF,
    0xFF5555,
    0xFF55FF,
    0xFFFF55,
    0xFFFFFF,
    0x555555,
    0x5555FF,
    0x55FF55,
    0x55FFFF,
    0xFF5555,
    0xFF55FF,
    0xFFFF55,
    0xFFFFFF
}
setmetatable(palette16, {
    __index = function(t, key)
        return rawget(t, band(key, 0x0F))
    end
})

local pixel_data_lookup = {
    [0] = 0x00, 0x02, 0x20, 0x22,
    0x01, 0x03, 0x21, 0x23,
    0x10, 0x12, 0x30, 0x32,
    0x11, 0x13, 0x31, 0x33
}

local data_rotate_functions = {
    [0x00] = function(self, a, b) -- SET
        return bor(band(a, self.gc_mask), band(b, bnot(self.gc_mask)))
    end,
    [0x01] = function(self, a, b) -- AND
        return band(bor(a, bnot(self.gc_mask)), b)
    end,
    [0x02] = function(self, a, b) -- OR
        return bor(band(a, self.gc_mask), b)
    end,
    [0x03] = function(self, a, b) -- XOR
        return bxor(band(a, self.gc_mask), b)
    end
}

local gc_modes = {
    [0x00] = function(self, vram_addr, write_mask, val)
        local data = ega_rotate[self.gc_data_rotate_count * 256 + val]

        for i = 0, 3, 1 do
            local mask = lshift(1, i)

            if band(self.gc_set_enabled, mask) ~= 0 then
                if band(self.gc_set_reset, mask) ~= 0 then
                    data = 0xFF
                else
                    data = 0x00
                end
            end

            if band(write_mask, mask) ~= 0 then
                self.vram[bor(vram_addr, i)] = data_rotate_functions[self.gc_data_rotate_function](self, data, self.latches[i])
            end
        end
    end,
    [0x01] = function(self, vram_addr, write_mask, val)
        for i = 0, 3, 1 do
            local mask = lshift(1, i)

            if band(write_mask, mask) ~= 0 then
                self.vram[bor(vram_addr, i)] = self.latches[i]
            end
        end
    end,
    [0x02] = function(self, vram_addr, write_mask, val)
        for i = 0, 3, 1 do
            local mask = lshift(1, i)
            local pixel

            if band(val, mask) ~= 0 then
                pixel = 0xFF
            else
                pixel = 0x00
            end

            self.vram[bor(vram_addr, i)] = data_rotate_functions[self.gc_data_rotate_function](self, pixel, self.latches[i])
        end
    end
}

-- VRAM
local function get_vram_addr(self, addr)
    local ret = band(addr, self.vram_addr_mask)

    if self.vram_a0mux == 2 then
        ret = bor(band(ret, bnot(0x01)), band(rshift(bnot(self.mor), 5), 0x01))
    elseif self.vram_a0mux == 3 then
        ret = bor(band(ret, bnot(0x01)), band(rshift(addr, 14), 0x01))
    elseif self.vram_a0mux == 6 then
        ret = bor(band(ret, bnot(0x01)), band(rshift(addr, 16), 0x01))
    end

    if not self.seq_extended_memory then
        ret = band(ret, 0x3FFF)
    end

    return ret
end

local function vram_read(self, addr)
    local vram_addr = lshift(get_vram_addr(self, addr - self.vram_start), 2)
    local read_plane = self.gc_read_plane

    if self.gc_odd_even then
        read_plane = bor(band(read_plane, 0x02), band(addr, 0x01))
    end

    self.latches[0] = self.vram[vram_addr]
    self.latches[1] = self.vram[bor(vram_addr, 0x01)]
    self.latches[2] = self.vram[bor(vram_addr, 0x02)]
    self.latches[3] = self.vram[bor(vram_addr, 0x03)]

    if self.gc_read_mode then
        local temp = {[0] = self.latches[0], self.latches[1], self.latches[2], self.latches[3]}

        for i = 0, 3, 1 do
            local mask = lshift(1, i)

            temp[i] = band(bxor(temp[i], (band(self.gc_color_compare, mask) ~= 0) and 0xFF or 0x00), (band(self.gc_color_no_care, mask) ~= 0) and 0xFF or 0x00)
        end

        return bnot(bor(temp[0], bor(temp[1], bor(temp[2], temp[3]))))
    end

    return self.vram[bor(vram_addr, read_plane)]
end

local function vram_write(self, addr, val)
    local vram_addr = lshift(get_vram_addr(self, addr - self.vram_start), 2)
    local write_mask = self.seq_map_mask

    if self.seq_odd_even then
        write_mask = band(write_mask, lshift(5, band(addr, 0x01)))
    end

    gc_modes[self.gc_write_mode](self, vram_addr, write_mask, val)
end

local function get_addr(self, addr)
    local new_addr = addr

    if self.crtc_word_mode then -- Word Mode
        local bit

        if self.crtc_address_warp then -- Address Warp
            bit = rshift(band(addr, 0x2000), 13)
        else
            bit = rshift(band(addr, 0x8000), 15)
        end

        new_addr = bor(lshift(new_addr, 1), bit)
    end

    if self.crtc_cga_compatibility_mode then
        new_addr = bor(band(new_addr, bnot(0x8000)), lshift(band(self.scanline, 0x01), 15))
    end

    return new_addr
end

local function render_line_empty(self)
    local screen_addr = self.current_line * self.width

    for x = 0, self.width - 1, 1 do
        self.screen:set_pixel_rgb_i(screen_addr + x, 0x000000)
    end
end

local function render_text(self)
    local screen_index = self.current_line * self.width
    local blinked = band(self.blink, 0x10) ~= 0

    for x = 0, self.width - 1, self.glyph_width do
        local addr = get_addr(self, self.memory_addr)
        local chr = self.vram[addr]
        local attr = self.vram[addr + 1]
        local glyph_addr

        if band(attr, 0x08) ~= 0 then
            glyph_addr = self.seq_char_set_b
        else
            glyph_addr = self.seq_char_set_a
        end

        local glyph_row = self.vram[glyph_addr + lshift(chr, 7) + lshift(self.scanline, 2)]
        local foreground = self.palette[self.ac_palette[band(attr, 0x0F)]]
        local background

        if (self.memory_addr == lshift(self.crtc_cursor_pos, 2)) and self.cursor_visible and self.cursor_on then
            background = foreground
            foreground = self.palette[self.ac_palette[rshift(attr, 4)]]
        else
            if self.ac_enable_blink_or_intensity and (band(attr, 0x80) ~= 0) then
                background = self.palette[self.ac_palette[band(rshift(attr, 4), 0x07)]]

                if blinked then
                    foreground = background
                end
            else
                background = self.palette[self.ac_palette[rshift(attr, 4)]]
            end
        end

        for glyph_x = 0, self.glyph_width - 1, 1 do
            local color

            if band(glyph_row, rshift(0x80, glyph_x)) ~= 0 then
                color = foreground
            else
                color = background
            end

            self.screen:set_pixel_rgb_i(screen_index + x + glyph_x, color)
        end

        self.memory_addr = self.memory_addr + 4
    end
end

local function render_graphics(self)
    local clock = 0
    local screen_address = self.current_line * self.width
    local data = {0, 0, 0, 0}

    for x = 0, self.width - 1, self.glyph_width do
        local addr = get_addr(self, self.memory_addr)

        if self.seq_shift_load then
            data[1] = self.vram[bxor(addr, clock)]
            data[2] = self.vram[bxor(bor(addr, 0x01), clock)]
            data[3] = self.vram[bxor(bor(addr, 0x02), clock)]
            data[4] = self.vram[bxor(bor(addr, 0x03), clock)]
            clock = band(clock + 1, 0x01)

            if clock == 0 then
                self.memory_addr = self.memory_addr + 4
            end
        else
            data[1] = self.vram[addr]
            data[2] = self.vram[bor(addr, 0x01)]
            data[3] = self.vram[bor(addr, 0x02)]
            data[4] = self.vram[bor(addr, 0x03)]

            self.memory_addr = self.memory_addr + 4
        end

        self.memory_addr = band(self.memory_addr, 0x3FFFF)

        if self.gc_shift_mode then
            local temp1 = bor(cga2ega[data[2]], lshift(cga2ega[data[1]], 4))
            local temp2 = bor(cga2ega[rshift(data[2], 1)], lshift(cga2ega[rshift(data[1], 1)], 4))
            local temp3 = bor(cga2ega[data[4]], lshift(cga2ega[data[3]], 4))
            local temp4 = bor(cga2ega[rshift(data[4], 1)], lshift(cga2ega[rshift(data[3], 1)], 4))

            data[1] = temp1
            data[2] = temp2
            data[3] = temp3
            data[4] = temp4
        end

        for i = 0, 7, 2 do
            local in_shift = 6 - i
            local pixel_data = bor(pixel_data_lookup[lshift(band(rshift(data[1], in_shift), 0x03), 2) + band(rshift(data[2], in_shift), 0x03)], lshift(pixel_data_lookup[lshift(band(rshift(data[3], in_shift), 0x03), 2) + band(rshift(data[4], in_shift), 0x03)], 2))
            local palette_index_0 = band(band(rshift(pixel_data, 4), 0x0F), self.ac_color_plane_enabled)
            local palette_index_1 = band(band(pixel_data, 0x0F), self.ac_color_plane_enabled)
            local color0 = self.palette[self.ac_palette[palette_index_0]]
            local color1 = self.palette[self.ac_palette[palette_index_1]]

            self.screen:set_pixel_rgb_i(screen_address + x + i, color0)
            self.screen:set_pixel_rgb_i(screen_address + x + i + 1, color1)
        end
    end
end

local function update_screen(self)
    self.width = self.crtc_horizontal_display_end
    self.height = self.crtc_vertical_display_end

    if not self.gc_graphics_mode then
        self.glyph_width = self.seq_dot_clocks and 8 or 9
        self.width = self.width * self.glyph_width
        self.render = render_text
    else
        self.glyph_width = 8
        self.width = self.width * 8
        self.render = render_graphics
    end

    if self.seq_dot_clock then
        self.screen.scale_x = 2.0
    else
        self.screen.scale_x = 1.0
    end

    if band(self.mor, 0x80) == 0 then
        self.screen.scale_y = 2.0
    else
        self.screen.scale_y = 1.0
    end

    if self.width < 64 then
        self.width = 640
    end

    if self.height < 32 then
        self.height = 200
    end

    self.screen:set_resolution(self.width, self.height)
end

local function rom_read(self, addr)
    return self[band(addr, 0x7FFF)]
end

local function rom_write(self, addr, val)
    self[band(addr, 0x7FFF)] = val
end

-- Ports
local function port_mor_out(self) -- Miscellaneous Output Register
    return function(cpu, port, val)
        local io_address = band(val, 0x01)

        if band(self.mor, 0x01) ~= io_address then
            local cpu_io = cpu:get_io()

            if io_address == 0x01 then
                cpu_io:set_port(0x3B4, nil, nil)
                cpu_io:set_port(0x3B5, nil, nil)
                cpu_io:set_port(0x3BA, nil, nil)
            else
                cpu_io:set_port(0x3B4, cpu_io:get_port(0x3D4))
                cpu_io:set_port(0x3B5, cpu_io:get_port(0x3D5))
                cpu_io:set_port(0x3BA, cpu_io:get_port(0x3DA))
            end
        end

        self.mor = val
        self.switch_select = rshift(band(val, 0x0C), 2)

        if band(self.mor, 0x80) == 0 then
            self.palette = palette16
        else
            self.palette = palette64
        end

        update_screen(self)
    end
end

local function port_isr0_in(self) -- Input Status Register 0 
    return function(cpu, port)
        return bor(lshift(band(rshift(self.switch, 3 - self.switch_select), 0x01), 4), lshift(self.fcr, 5))
    end
end

local function port_fcr_out(self)
    return function(cpu, port, val)
        self.fcr = val
    end
end

local function port_isr1_in(self) -- Input Status Register 1
    return function(cpu, port)
        self.ac_flipflop = false
        self.status1 = bxor(self.status1, 0x39)
        return self.status1
    end
end

-- Sequencer Registers
local seq_regs_write = {
    [0x00] = function(self, val) -- Reset Register
        self.seq_reset = band(val, 0x03)
    end,
    [0x01] = function(self, val) -- Clocking Mode Register
        self.seq_dot_clocks = band(val, 0x01) ~= 0
        self.seq_shift_load = band(val, 0x04) ~= 0
        self.seq_dot_clock = band(val, 0x08) ~= 0

        update_screen(self)
    end,
    [0x02] = function(self, val) -- Map Mask Register
        self.seq_map_mask = band(val, 0x0F)
    end,
    [0x03] = function(self, val) -- Character Map Select Register
        self.seq_char_set_a = (band(rshift(val, 2), 0x03) * 0x10000) + 2
        self.seq_char_set_b = (band(val, 0x03) * 0x10000) + 2
    end,
    [0x04] = function(self, val) -- Memory Mode Register
        self.seq_extended_memory = band(val, 0x02) ~= 0
        self.seq_odd_even = band(val, 0x04) == 0
    end
}

local function port_seq_addr_register_out(self)
    return function(cpu, port, val)
        self.seq_index = band(val, 0x0F)
    end
end

local function port_seq_data_register_out(self)
    return function(cpu, port, val)
        local reg = seq_regs_write[self.seq_index]

        if reg then
            reg(self, val)
        end
    end
end

-- CRTC
local crtc_regs_write = {
    [0x00] = function(self, val) -- Horizontal Total Register
    end,
    [0x01] = function(self, val) -- Horizontal Display Enable End Register
        self.crtc_horizontal_display_end = band(val, 0xFF) + 1
        update_screen(self)
    end,
    [0x02] = function(self, val) -- Start Horizontal Blank Register
    end,
    [0x03] = function(self, val) -- End Horizontal Blank Register
    end,
    [0x04] = function(self, val) -- Start Horizontal Retrace Register
    end,
    [0x05] = function(self, val) -- End Horizontal Retrace Register
    end,
    [0x06] = function(self, val) -- Vertical Total Register
        self.crtc_vertical_total = bor(band(self.crtc_vertical_total, 0xFF00), val) + 2
    end,
    [0x07] = function(self, val) -- Overflow Register
        local overflow = band(val, 0xFF)

        self.crtc_vertical_total = bor(band(self.crtc_vertical_total, 0x00FF), lshift(band(overflow, 0x01), 8))
        self.crtc_vertical_display_end = bor(band(self.crtc_vertical_display_end, 0x00FF), lshift(band(overflow, 0x02), 7))
        self.crtc_vertical_retrace_start = bor(band(self.crtc_vertical_retrace_start, 0x00FF), lshift(band(overflow, 0x04), 6))
        self.crtc_start_vertical_blank = bor(band(self.crtc_start_vertical_blank, 0x00FF), lshift(band(overflow, 0x08), 5))
        self.crtc_line_compare = bor(band(self.crtc_line_compare, 0x00FF), lshift(band(overflow, 0x10), 4))
    end,
    [0x08] = function(self, val) -- Preset Row Scan Register
        self.crtc_preset_row_scan = band(val, 0xFF)
    end,
    [0x09] = function(self, val) -- Max Scan Line Register
        self.crtc_max_scanline = band(val, 0x1F)
    end,
    [0x0A] = function(self, val) -- Cursor Start Register
        self.crtc_cursor_start = band(val, 0x1F)
    end,
    [0x0B] = function(self, val) -- Cursor End Register
        self.crtc_cursor_end = band(val, 0x1F)
    end,
    [0x0C] = function(self, val) -- Start Address Register HIGH
        self.memory_addr_latch = bor(band(self.memory_addr_latch, 0x00FF), lshift(val, 8))
    end,
    [0x0D] = function(self, val) -- Start address Register LOW
        self.memory_addr_latch = bor(band(self.memory_addr_latch, 0xFF00), val)
    end,
    [0x0E] = function(self, val) -- Cursor Location Register HIGH
        self.crtc_cursor_pos = bor(band(self.crtc_cursor_pos, 0x00FF), lshift(val, 8))
    end,
    [0x0F] = function(self, val) -- Cursor Location Register LOW
        self.crtc_cursor_pos = bor(band(self.crtc_cursor_pos, 0xFF00), val)
    end,
    [0x10] = function(self, val) -- Vertical Retrace Start Register
        self.crtc_vertical_retrace_start = bor(band(self.crtc_vertical_retrace_start, 0xFF00), val) + 1
    end,
    [0x11] = function(self, val) -- Vertical Retrace End Register
    end,
    [0x12] = function(self, val) -- Vertical Display End Register
        self.crtc_vertical_display_end = bor(band(self.crtc_vertical_display_end, 0xFF00), val) + 1
        update_screen(self)
    end,
    [0x13] = function(self, val) -- Offset Register
        self.crtc_offset = band(val, 0xFF)
    end,
    [0x14] = function(self, val) -- Underline Location Register
    end,
    [0x15] = function(self, val) -- Start Vertical Blank Register
        self.crtc_start_vertical_blank = bor(band(self.crtc_start_vertical_blank, 0xFF00), val)
    end,
    [0x16] = function(self, val) -- End Vertical Blank Register
    end,
    [0x17] = function(self, val) -- Mode Control Register
        self.crtc_reset = band(val, 0x80) == 0
        self.crtc_word_mode = band(val, 0x40) == 0
        self.crtc_address_warp = band(val, 0x20) == 0
        self.crtc_cga_compatibility_mode = band(val, 0x01) == 0
    end,
    [0x18] = function(self, val) -- Line Compare Register
        self.crtc_line_compare = bor(band(self.crtc_line_compare, 0xFF00), val) + 1
    end
}

local crtc_regs_read = {
    [0x0E] = function(self)
        return band(rshift(self.crtc_cursor_pos, 8), 0xFF)
    end,
    [0x0F] = function(self)
        return band(self.crtc_cursor_pos, 0xFF)
    end
}

local function port_crtc_addr_register_out(self)
    return function(cpu, port, val)
        self.crtc_index = band(val, 0x1F)
    end
end

local function port_crtc_addr_register_in(self)
    return function(cpu, port)
        return self.crtc_index
    end
end

local function port_crtc_data_register_out(self)
    return function(cpu, port, val)
        local reg = crtc_regs_write[self.crtc_index]

        if reg then
            reg(self, val)
        end
    end
end

local function port_crtc_data_register_in(self)
    return function(cpu, port)
        local reg = crtc_regs_read[self.crtc_index]

        if reg then
            return reg(self)
        end

        return 0xFF
    end
end

-- Graphics Controller
local gc_regs = {
    [0x00] = function(self, val) -- Set / Reset Register
        self.gc_set_reset = band(val, 0x0F)
    end,
    [0x01] = function(self, val) -- Enable Set / Reset Registe
        self.gc_set_enabled = band(val, 0x0F)
    end,
    [0x02] = function(self, val) -- Color Compare Register
        self.gc_color_compare = band(val, 0x0F)
    end,
    [0x03] = function(self, val) -- Data Rotate Register
        self.gc_data_rotate_count = band(val, 0x07)
        self.gc_data_rotate_function = band(rshift(val, 3), 0x03)
    end,
    [0x04] = function(self, val) -- Read Map Select Register
        self.gc_read_plane = band(val, 0x03)
    end,
    [0x05] = function(self, val) -- Mode Register
        self.gc_read_mode = band(val, 0x08) ~= 0
        self.gc_write_mode = band(val, 0x03)
        self.gc_test_condition = band(val, 0x04) ~= 0
        self.gc_odd_even = band(val, 0x10) ~= 0
        self.gc_shift_mode = band(val, 0x20) ~= 0
    end,
    [0x06] = function(self, val) -- Miscellaneous Register
        local memory_map = rshift(band(val, 0x0C), 2)
        local vram_size

        self.vram_a0mux = band(self.vram_a0mux, bnot(0x04))
        self.memory:remove_mapping(0xA0000, 0x20000)

        if memory_map == 0 then -- 128 KB
            self.vram_start = 0xA0000
            vram_size = 0x20000
            self.vram_a0mux = bor(self.vram_a0mux, 0x04)
            self.vram_addr_mask = 0xFFFF
        elseif memory_map == 1 then -- 64 KB
            self.vram_start = 0xA0000
            vram_size = 0x10000
            self.vram_addr_mask = 0xFFFF
        elseif memory_map == 2 then -- 32 KB
            self.vram_start = 0xB0000
            vram_size = 0x08000
            self.vram_addr_mask = 0x7FFF
        elseif memory_map == 3 then -- 32 KB
            self.vram_start = 0xB8000
            vram_size = 0x08000
            self.vram_addr_mask = 0x7FFF
        end

        self.memory:set_mapping(self.vram_start, vram_size, vram_read, vram_write, self)
        self.gc_graphics_mode = band(val, 0x01) ~= 0
        self.gc_chain_odd_even = band(val, 0x02) ~= 0
        self.gc_memory_map = memory_map
        self.vram_a0mux = bor(band(self.vram_a0mux, bnot(0x02)), band(val, 0x02))

        update_screen(self)
    end,
    [0x07] = function(self, val) -- Color Don't Care Register
        self.gc_color_no_care = band(val, 0x0F)
    end,
    [0x08] = function(self, val) -- Bit Mask Register
        self.gc_mask = band(val, 0xFF)
    end
}

local function port_gc_addr_out(self)
    return function(cpu, port, val)
        self.gc_index = band(val, 0x0F)
    end
end

local function port_gc_data_out(self)
    return function(cpu, port, val)
        local reg = gc_regs[self.gc_index]

        if reg then
            reg(self, val)
        end
    end
end

-- Attribute Controller
local function write_palette(self, val)
    self.ac_palette[self.ac_index] = band(val, 0x3F)
end

local ac_regs = {
    [0x00] = write_palette, -- 0x00 - 0x0F - Palette Registers
    [0x01] = write_palette,
    [0x02] = write_palette,
    [0x03] = write_palette,
    [0x04] = write_palette,
    [0x05] = write_palette,
    [0x06] = write_palette,
    [0x07] = write_palette,
    [0x08] = write_palette,
    [0x09] = write_palette,
    [0x0A] = write_palette,
    [0x0B] = write_palette,
    [0x0C] = write_palette,
    [0x0D] = write_palette,
    [0x0E] = write_palette,
    [0x0F] = write_palette,
    [0x10] = function(self, val) -- Mode Control Register
        self.ac_graphics_mode = band(val, 0x01) ~= 0
        self.ac_mono_mode = band(val, 0x02) ~= 0
        self.ac_enable_line_character_codes = band(val, 0x04) ~= 0
        self.ac_enable_blink_or_intensity = band(val, 0x08) ~= 0
    end,
    [0x11] = function(self, val)
        self.ac_overscan_color = band(val, 0xFF)
    end,
    [0x12] = function(self, val)
        self.ac_color_plane_enabled = band(val, 0x0F)
        self.ac_video_status_mux = rshift(band(val, 0x20), 4)
    end,
    [0x13] = function(self, val)
        self.ac_pel_panning = band(val, 0x0F)
    end
}

local function port_ac_out(self)
    return function(cpu, port, val)
        if not self.ac_flipflop then
            self.ac_index = band(val, 0x1F)
            self.ac_flipflop = true
        else
            local reg = ac_regs[self.ac_index]

            if reg then
                reg(self, val)
            end

            self.ac_flipflop = false
        end
    end
end

-- Render
local function update(self)
    for _ = 1, 1000, 1 do
        if self.vertical_beam then
            self.vertical_beam = false

            if self.display_on then
                if not self.crtc_reset then
                    self:render() 
                else
                    render_line_empty(self)
                end
            end

            self.current_line = self.current_line + 1

            if self.current_line > 500 then
                self.current_line = 0
            end
        else
            self.vertical_beam = true

            if (self.scanline == self.crtc_cursor_end) or (self.scanline == self.crtc_max_scanline) then
                self.cursor_visible = false
            end

            if self.display_on then
                if self.scanline == self.crtc_max_scanline then
                    self.scanline = 0
                    self.memory_addr_backup = band(self.memory_addr_backup + lshift(self.crtc_offset, 3), self.memory_mask)
                    self.memory_addr = self.memory_addr_backup
                else
                    self.scanline = band(self.scanline + 1, 0x1F)
                    self.memory_addr = self.memory_addr_backup
                end
            end

            self.vertical_count = band(self.vertical_count + 1, 0x1FF)

            if self.vertical_count == self.crtc_line_compare then
                self.memory_addr_backup = 0
                self.memory_addr = self.memory_addr_backup
                self.scanline = 0
            end

            if self.vertical_count == self.crtc_vertical_display_end then
                self.display_on = false
                self.cursor_on = band(self.blink, 0x10) ~= 0
                self.blink = band(self.blink + 1, 0x7F)
            end

            if self.vertical_count == self.crtc_vertical_retrace_start then
                self.display_on = false
                self.memory_addr_backup = lshift(self.memory_addr_latch, 2)
                self.memory_addr = self.memory_addr_backup
            end

            if self.vertical_count == self.crtc_vertical_total then
                self.display_on = true
                self.vertical_count = 0
                self.scanline = self.crtc_preset_row_scan
                self.current_line = 0
                self.memory_addr_backup = 0
                self.memory_addr = self.memory_addr_backup

                if self.crtc_vertical_total > 0 then
                   self.screen:update()
                end
            end

            if self.scanline == self.crtc_cursor_start then
                self.cursor_visible = true
            end
        end
    end
end

local function get_type(self)
    return common.TYPE.CGA
end

local function initialize(self)
    for i = 1, #EGA_ROM, 1 do
        self.rom[i - 1] = EGA_ROM[i]
    end
end

local function reset(self)
    self.latches[0] = 0
    self.latches[1] = 0
    self.latches[2] = 0
    self.latches[3] = 0
    self.vertical_beam = true
    self.crtc_index = 0
    self.crtc_horizontal_display_end = 0
    self.crtc_vertical_total = 31
    self.crtc_vertical_display_end = 0
    self.crtc_preset_row_scan = 0
    self.crtc_max_scanline = 0
    self.crtc_cursor_start = 0
    self.crtc_cursor_end = 0
    self.crtc_offset = 0
    self.crtc_start_vertical_blank = 0
    self.crtc_line_compare = 0
    self.crtc_cursor_pos = 0
    self.crtc_word_mode = false
    self.crtc_address_warp = false
    self.crtc_cga_compatibility_mode = false
    self.crtc_reset = false
    self.cursor_on = false
    self.cursor_visible = false
    self.current_line = 0
    self.vertical_count = 0
    self.memory_addr = 0
    self.memory_addr_backup = 0
    self.memory_addr_latch = 0
    self.memory_mask = 0xFFFF
    self.scanline = 0
    self.glyph_width = 0
    self.blink = 0
    self.odd_even = false
    self.display_on = false
    self.width = 0
    self.height = 0
    self.mor = 0x23
    self.vram_addr_mask = 0xFFFF
    self.vram_a0mux = 0
    self.switch_select = 0
    self.palette = palette16
    self.seq_index = 0
    self.seq_map_mask = 0xFF
    self.seq_reset = 0
    self.seq_dot_clocks = false
    self.seq_shift_load = false
    self.seq_dot_clock = false
    self.seq_char_set_a = 0
    self.seq_char_set_b = 0
    self.seq_odd_even = 0
    self.seq_extended_memory = true
    self.gc_index = 0
    self.gc_color_compare = 0
    self.gc_color_no_care = 0
    self.gc_read_plane = 0
    self.gc_set_enabled = 0
    self.gc_set_reset = 0
    self.gc_mask = 0x00
    self.gc_chain_odd_even = false
    self.gc_memory_map = 0x00
    self.gc_read_mode = false
    self.gc_write_mode = 0
    self.gc_test_condition = 0
    self.gc_odd_even = 0
    self.gc_shift_mode = 0
    self.gc_data_rotate_count = 0
    self.gc_data_rotate_function = 0
    self.gc_graphics_mode = false
    self.ac_flipflop = false
    self.ac_index = 0
    self.ac_pel_panning = 0
    self.fcr = 0
    self.status1 = 0
end

function ega.new(cpu, memory, screen)
    local self = {
        memory = memory,
        screen = screen,
        rom = {},
        latches = {[0] = 0, 0, 0, 0},
        vertical_beam = true,
        crtc_index = 0,
        crtc_horizontal_display_end = 0,
        crtc_vertical_total = 31,
        crtc_vertical_display_end = 80,
        crtc_vertical_retrace_start = 350,
        crtc_preset_row_scan = 0,
        crtc_max_scanline = 0,
        crtc_cursor_start = 0,
        crtc_cursor_end = 0,
        crtc_offset = 0,
        crtc_start_vertical_blank = 0,
        crtc_line_compare = 0,
        crtc_cursor_pos = 0,
        crtc_word_mode = false,
        crtc_address_warp = false,
        crtc_cga_compatibility_mode = false,
        crtc_reset = false,
        cursor_on = false,
        cursor_visible = false,
        current_line = 0,
        vertical_count = 0,
        memory_addr = 0,
        memory_addr_backup = 0,
        memory_addr_latch = 0,
        memory_mask = 0xFFFF,
        scanline = 0,
        glyph_width = 0,
        blink = 0,
        odd_even = false,
        display_on = false,
        width = 0,
        height = 0,
        mor = 0x23,
        vram_addr_mask = 0xFFFF,
        vram_a0mux = 0,
        switch_select = 0,
        palette = palette16,
        seq_index = 0,
        seq_map_mask = 0xFF,
        seq_reset = 0,
        seq_dot_clocks = false,
        seq_shift_load = false,
        seq_dot_clock = false,
        seq_char_set_a = 0,
        seq_char_set_b = 0,
        seq_odd_even = 0,
        seq_extended_memory = true,
        gc_index = 0,
        gc_color_compare = 0,
        gc_color_no_care = 0,
        gc_read_plane = 0,
        gc_set_enabled = 0,
        gc_set_reset = 0,
        gc_mask = 0x00,
        gc_chain_odd_even = false,
        gc_memory_map = 0x00,
        gc_read_mode = false,
        gc_write_mode = 0,
        gc_test_condition = 0,
        gc_odd_even = 0,
        gc_shift_mode = 0,
        gc_data_rotate_count = 0,
        gc_data_rotate_function = 0,
        gc_graphics_mode = false,
        ac_flipflop = false,
        ac_index = 0,
        ac_palette = {[0] = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        ac_pel_panning = 0,
        fcr = 0,
        vram_size = 256 * 1024,
        switch = 0x09,
        status1 = 0,
        vram = {},
        vram_start = 0xA0000,
        get_type = get_type,
        render = render_graphics,
        initialize = initialize,
        update = update,
        reset = reset
    }

    local cpu_io = cpu:get_io()

    cpu_io:set_port_out_range(0x3C0, 0x3C1, port_ac_out(self))
    cpu_io:set_port(0x3C2, port_mor_out(self), port_isr0_in(self))
    cpu_io:set_port(0x3DA, port_fcr_out(self), port_isr1_in(self))
    cpu_io:set_port_out(0x3C4, port_seq_addr_register_out(self))
    cpu_io:set_port_out(0x3C5, port_seq_data_register_out(self))
    cpu_io:set_port(0x3D4, port_crtc_addr_register_out(self), port_crtc_addr_register_in(self))
    cpu_io:set_port(0x3D5, port_crtc_data_register_out(self), port_crtc_data_register_in(self))
    cpu_io:set_port_out(0x3CE, port_gc_addr_out(self))
    cpu_io:set_port_out(0x3CF, port_gc_data_out(self))

    if self.vram_size <= 64 * 1024 then
        self.vram_a0mux = bor(self.vram_a0mux, 0x01)
    end

    for i = 0, 0x3FFFF, 1 do
        self.vram[i] = 0x00
    end

    memory:set_mapping(0xC0000, 0x8000, rom_read, rom_write, self.rom)
    memory:set_mapping(0xA0000, 0x20000, vram_read, vram_write, self)

    self.memory_mask = self.vram_size - 1

    return self
end

return ega
